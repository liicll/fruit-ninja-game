<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç½‘é¡µç‰ˆæ°´æœåˆ‡åˆ‡ä¹</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* é˜²æ­¢ç§»åŠ¨ç«¯æ»šåŠ¨ */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /* ä¿®æ”¹ä¸ºæœ¨å¤´èœæ¿èƒŒæ™¯ */
            background-color: #8b5a2b;
            background-image: 
                radial-gradient(circle, rgba(0,0,0,0.1), rgba(0,0,0,0.6)), /* ä¸­é—´äº®å››å‘¨æš—çš„ç¯å…‰æ•ˆæœ */
                repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 12px), /* ç»†æœ¨çº¹ */
                linear-gradient(to bottom, #a0522d, #5c3317); /* æœ¨å¤´åº•è‰²æ¸å˜ */
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5); /* è¾¹ç¼˜åŠ æ·± */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI è¦†ç›–å±‚ */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ° Canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .score-board {
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: flex;
            gap: 20px;
        }

        .lives {
            color: #ff4757;
        }

        /* èœå•å±å¹• */
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        p {
            font-size: 18px;
            color: #ddd;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #ff6b6b, #ff4757);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 71, 87, 0.6);
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        #final-score {
            font-size: 60px;
            font-weight: bold;
            color: #2ed573;
            margin: 20px 0;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- æ¸¸æˆ UI -->
    <div class="ui-layer">
        <div class="score-board">
            <span id="score-display">åˆ†æ•°: 0</span>
            <span id="best-score-display">æœ€é«˜: 0</span>
        </div>
        <div class="lives" id="lives-display">â¤ï¸â¤ï¸â¤ï¸</div>
    </div>

    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen">
        <h1>ğŸ‰ æ°´æœåˆ‡åˆ‡ä¹ ğŸŒ</h1>
        <p>æ»‘åŠ¨é¼ æ ‡æˆ–æ‰‹æŒ‡åˆ‡å¼€æ°´æœï¼Œåƒä¸‡åˆ«åˆ‡ç‚¸å¼¹ï¼</p>
        <button id="start-btn">å¼€å§‹åˆ‡æ°´æœ</button>
    </div>

    <!-- ç»“æŸç•Œé¢ -->
    <div id="game-over-screen" class="hidden">
        <h1>æ¸¸æˆç»“æŸ</h1>
        <p>æœ¬å±€å¾—åˆ†</p>
        <div id="final-score">0</div>
        <button id="restart-btn">å†æ¥ä¸€å±€</button>
    </div>
</div>

<script>
    // --- æ¸¸æˆé…ç½®ä¸å…¨å±€å˜é‡ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI å…ƒç´ 
    const scoreEl = document.getElementById('score-display');
    const bestScoreEl = document.getElementById('best-score-display');
    const livesEl = document.getElementById('lives-display');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');

    // æ¸¸æˆçŠ¶æ€
    let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
    let score = 0;
    let lives = 3;
    let gameTime = 0;
    let difficultyMultiplier = 1;
    
    // å®ä½“æ•°ç»„
    let fruits = [];
    let particles = [];
    let trailPoints = [];

    // æ°´æœå®šä¹‰ (åŠå¾„è°ƒå¤§)
    const FRUIT_TYPES = [
        { emoji: 'ğŸ‰', color: '#ff6b6b', points: 10, radius: 50 },
        { emoji: 'ğŸŒ', color: '#ffeaa7', points: 15, radius: 45 },
        { emoji: 'ğŸ', color: '#ff4757', points: 10, radius: 45 },
        { emoji: 'ğŸ', color: '#f9ca24', points: 20, radius: 50 },
        { emoji: 'ğŸŠ', color: '#ff9f43', points: 10, radius: 45 },
        { emoji: 'ğŸ¥¥', color: '#dfe4ea', points: 25, radius: 48 },
        { emoji: 'ğŸ¥', color: '#badc58', points: 15, radius: 45 }
    ];

    const BOMB_TYPE = { emoji: 'ğŸ’£', color: '#2f3542', radius: 50 };

    // é¼ æ ‡/è§¦æ‘¸è¿½è¸ª
    const input = { x: 0, y: 0, isDown: false, history: [] };

    // --- éŸ³æ•ˆç³»ç»Ÿ (æ–°å¢) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new AudioContext();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    // åˆæˆæŒ¥åˆ€/åˆ‡å¼€çš„å£°éŸ³
    function playSliceSound(type = 'slice') {
        if (!audioCtx) return;

        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        // ä½¿ç”¨å™ªå£°æ¥æ¨¡æ‹Ÿåˆ‡çš„å£°éŸ³
        const bufferSize = audioCtx.sampleRate * 0.1; // 0.1ç§’
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        if (type === 'slice') {
            // åˆ‡ä¸­æ°´æœï¼šæ¸…è„†çš„å™—å‘²å£° (é«˜é€šæ»¤æ³¢)
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(800, t);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        } else if (type === 'throw') {
            // æŠ›å‡ºå£°éŸ³ï¼šä½æ²‰ä¸€ç‚¹
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(600, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.2);
        }

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        noise.start();
    }

    // --- åˆå§‹åŒ–ä¸äº‹ä»¶ç›‘å¬ ---
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // é¼ æ ‡äº‹ä»¶
    canvas.addEventListener('mousedown', (e) => {
        input.isDown = true;
        input.x = e.clientX;
        input.y = e.clientY;
        trailPoints = []; // æ–°çš„ä¸€åˆ€
    });
    canvas.addEventListener('mousemove', (e) => {
        if (input.isDown) {
            input.x = e.clientX;
            input.y = e.clientY;
            addTrailPoint(input.x, input.y);
            checkCollisions(input.x, input.y);
        }
    });
    window.addEventListener('mouseup', () => {
        input.isDown = false;
        trailPoints = [];
    });

    // è§¦æ‘¸äº‹ä»¶ (é€‚é…æ‰‹æœº)
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        input.isDown = true;
        input.x = e.touches[0].clientX;
        input.y = e.touches[0].clientY;
        trailPoints = [];
    }, {passive: false});
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (input.isDown) {
            input.x = e.touches[0].clientX;
            input.y = e.touches[0].clientY;
            addTrailPoint(input.x, input.y);
            checkCollisions(input.x, input.y);
        }
    }, {passive: false});
    window.addEventListener('touchend', () => {
        input.isDown = false;
        trailPoints = [];
    });

    // æŒ‰é’®äº‹ä»¶
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);

    // åŠ è½½æœ€é«˜åˆ†
    let bestScore = localStorage.getItem('fruitNinjaBestScore') || 0;
    bestScoreEl.innerText = `æœ€é«˜: ${bestScore}`;

    // --- ç±»å®šä¹‰ ---

    class Fruit {
        constructor() {
            this.reset();
        }

        reset() {
            // éšæœºå†³å®šæ˜¯æ°´æœè¿˜æ˜¯ç‚¸å¼¹ (éšç€æ—¶é—´æ¨ç§»ç‚¸å¼¹æ¦‚ç‡å¢åŠ )
            const isBomb = Math.random() < Math.min(0.1 + (gameTime * 0.0001), 0.3);
            
            if (isBomb) {
                this.type = BOMB_TYPE;
                this.isBomb = true;
            } else {
                this.type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                this.isBomb = false;
            }

            // ä»åº•éƒ¨éšæœºä½ç½®ç”Ÿæˆï¼Œç¨å¾®å¾€ä¸­é—´é ä¸€ç‚¹ï¼Œé¿å…å¼€å±€å°±è´´è¾¹
            this.x = Math.random() * (canvas.width - 200) + 100;
            this.y = canvas.height + 50;
            
            this.gravity = 0.12; // é€‚ä¸­çš„é‡åŠ›
            
            // æŠ›ç‰©çº¿è¿åŠ¨å‚æ•°
            // Xè½´é€Ÿåº¦ï¼šå¦‚æœåœ¨å·¦è¾¹å°±å¾€å³é£ï¼Œå³è¾¹å°±å¾€å·¦é£
            const direction = this.x > canvas.width / 2 ? -1 : 1;
            this.vx = (Math.random() * 3 + 1) * direction; 

            // Yè½´é€Ÿåº¦ï¼šæ ¹æ®å±å¹•é«˜åº¦åŠ¨æ€è®¡ç®—ï¼Œä¿è¯æœ€é«˜ç‚¹å¤§æ¦‚åœ¨å±å¹• 60%-85% çš„é«˜åº¦
            // ç‰©ç†å…¬å¼ v = sqrt(2gh)
            const targetHeight = canvas.height * (0.6 + Math.random() * 0.25);
            this.vy = -Math.sqrt(2 * this.gravity * targetHeight);
            
            this.rotation = 0;
            this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            this.active = true;
            this.sliced = false;

            // æ’­æ”¾å‘å°„å£°éŸ³
            if (gameState === 'PLAYING') playSliceSound('throw');
        }

        update() {
            if (!this.active) return;

            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.rotation += this.rotationSpeed;

            // å·¦å³å¢™å£ç¢°æ’æ£€æµ‹ (åå¼¹)
            if (this.x - this.type.radius < 0) {
                this.x = this.type.radius; // ä¿®æ­£ä½ç½®
                this.vx *= -0.6; // åå¼¹å¹¶æŸå¤±ä¸€ç‚¹é€Ÿåº¦
            } else if (this.x + this.type.radius > canvas.width) {
                this.x = canvas.width - this.type.radius; // ä¿®æ­£ä½ç½®
                this.vx *= -0.6; // åå¼¹
            }

            // æ‰è½æ£€æµ‹
            if (this.y > canvas.height + 60) {
                this.active = false;
                if (!this.isBomb && !this.sliced && gameState === 'PLAYING') {
                    loseLife();
                }
            }
        }

        draw() {
            if (!this.active || this.sliced) return;

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.font = "80px Arial"; // å­—ä½“å˜å¤§
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.type.emoji, 0, 0); // æ­£å¸¸æ˜¾ç¤º
            // è°ƒè¯•ç”¨ï¼šç”»å‡ºç¢°æ’åœ†
            // ctx.beginPath();
            // ctx.arc(0, 0, this.type.radius, 0, Math.PI * 2);
            // ctx.stroke();
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0; // ä¸é€æ˜åº¦
            this.decay = Math.random() * 0.02 + 0.01;
            this.gravity = 0.1;
            this.size = Math.random() * 5 + 3;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.life -= this.decay;
        }

        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 1.0;
            this.vy = -2;
        }
        
        update() {
            this.y += this.vy;
            this.life -= 0.02;
        }
        
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.font = "bold 30px Arial";
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    // --- æ¸¸æˆé€»è¾‘å‡½æ•° ---

    function startGame() {
        initAudio(); // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡

        score = 0;
        lives = 3;
        gameTime = 0;
        difficultyMultiplier = 1;
        fruits = [];
        particles = [];
        trailPoints = [];
        updateUI();
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        
        gameState = 'PLAYING';
        gameLoop();
        spawnLoop();
    }

    function spawnLoop() {
        if (gameState !== 'PLAYING') return;

        // æ ¹æ®éš¾åº¦å†³å®šç”Ÿæˆé—´éš” (å¢åŠ åŸºç¡€é—´éš”ï¼Œè®©èŠ‚å¥æ›´æ…¢)
        const baseInterval = 1500;
        const interval = Math.max(600, baseInterval - (gameTime * 0.2));
        
        // æœ‰å‡ ç‡ä¸€æ¬¡ç”Ÿæˆå¤šä¸ª
        const count = Math.random() < 0.3 ? 2 : 1;

        for(let i=0; i<count; i++) {
            fruits.push(new Fruit());
        }

        // ç§»é™¤ä¸æ´»è·ƒçš„æ°´æœä»¥é‡Šæ”¾å†…å­˜
        fruits = fruits.filter(f => f.active);

        setTimeout(spawnLoop, interval);
    }

    function addTrailPoint(x, y) {
        trailPoints.push({ x, y, life: 1.0 });
    }

    function updateTrail() {
        for (let i = trailPoints.length - 1; i >= 0; i--) {
            trailPoints[i].life -= 0.1;
            if (trailPoints[i].life <= 0) {
                trailPoints.splice(i, 1);
            }
        }
    }

    function drawTrail() {
        if (trailPoints.length < 2) return;

        ctx.beginPath();
        ctx.moveTo(trailPoints[0].x, trailPoints[0].y);

        for (let i = 1; i < trailPoints.length; i++) {
            // å¹³æ»‘æ›²çº¿
            const p = trailPoints[i];
            const prevP = trailPoints[i-1];
            
            // åˆ€å…‰æ ·å¼
            ctx.strokeStyle = `rgba(255, 255, 255, ${p.life})`;
            ctx.lineWidth = p.life * 10;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // å¤–å‘å…‰æ•ˆæœ
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#00ffff';
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    function checkCollisions(mouseX, mouseY) {
        if (trailPoints.length < 2) return; // éœ€è¦ç§»åŠ¨æ‰èƒ½åˆ‡

        fruits.forEach(fruit => {
            if (fruit.active && !fruit.sliced) {
                // ç®€å•çš„è·ç¦»æ£€æµ‹
                const dx = mouseX - fruit.x;
                const dy = mouseY - fruit.y;
                const distance = Math.sqrt(dx*dx + dy*dy);

                if (distance < fruit.type.radius + 10) {
                    sliceFruit(fruit);
                }
            }
        });
    }

    function sliceFruit(fruit) {
        fruit.sliced = true;
        
        playSliceSound('slice'); // æ’­æ”¾åˆ‡å¼€éŸ³æ•ˆ

        if (fruit.isBomb) {
            createExplosion(fruit.x, fruit.y, '#fff');
            triggerGameOver();
        } else {
            // å¾—åˆ†
            score += fruit.type.points;
            updateUI();
            
            // ç‰¹æ•ˆï¼šæ±æ°´ç²’å­
            for (let i = 0; i < 15; i++) {
                particles.push(new Particle(fruit.x, fruit.y, fruit.type.color));
            }

            // ç‰¹æ•ˆï¼šæµ®åŠ¨åˆ†æ•°
            particles.push(new FloatingText(fruit.x, fruit.y, `+${fruit.type.points}`, '#fff'));

            // è§†è§‰åé¦ˆï¼šæ°´æœè¢«åˆ‡å¼€
            // è¿™é‡Œæˆ‘ä»¬ç®€å•åœ°ä¸å†ç»˜åˆ¶åŸæ°´æœï¼Œæ”¹ä¸ºç»˜åˆ¶ä¸¤ä¸ª"åŠä¸ª"æ°´æœå‘ä¸¤è¾¹é£å‡º
            // ä¸ºäº†ç®€åŒ–å•æ–‡ä»¶ä»£ç ï¼Œæˆ‘ä»¬ç”¨æ›´å¤šçš„ç²’å­ä»£æ›¿åˆ‡å¼€çš„å›¾åƒï¼Œæˆ–è€…ç»˜åˆ¶ä¸¤ä¸ªåŠåœ†
            createSlicedFruitEffect(fruit);
        }
    }

    function createSlicedFruitEffect(fruit) {
        // åˆ›å»ºä¸¤ä¸ªå‘åæ–¹å‘é£å‡ºçš„"åŠä¸ªæ°´æœ" (ç”¨æ–‡å­—ä»£æ›¿)
        // å®é™…ä¸Šä¸ºäº†ç®€å•å’Œæ€§èƒ½ï¼Œæˆ‘ä»¬è¿™é‡Œç”Ÿæˆå¤§é‡ç‰¹å®šé¢œè‰²çš„ç²’å­ï¼Œ
        // å†åŠ ä¸Šä¸€ä¸ªçŸ­æš‚æ˜¾ç¤ºçš„"åŠä¸ª"emojiå¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬ç”¨å¤§å—ç¢ç‰‡ä»£æ›¿
        
        // å·¦åŠè¾¹
        particles.push({
            x: fruit.x, y: fruit.y,
            vx: -5, vy: -5, gravity: 0.4,
            life: 1, color: fruit.type.color,
            draw: function() {
                ctx.globalAlpha = this.life;
                ctx.font = "70px Arial"; // åˆ‡å¼€çš„å°¸ä½“ä¹Ÿå˜å¤§
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(-0.5);
                ctx.fillText(fruit.type.emoji, -10, 0); // åç§»æ¨¡æ‹Ÿåˆ‡å¼€
                ctx.restore();
                ctx.globalAlpha = 1;
                this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.03;
            },
            update: function() {} // Dummy
        });

        // å³åŠè¾¹
        particles.push({
            x: fruit.x, y: fruit.y,
            vx: 5, vy: -5, gravity: 0.4,
            life: 1, color: fruit.type.color,
            draw: function() {
                ctx.globalAlpha = this.life;
                ctx.font = "70px Arial"; // åˆ‡å¼€çš„å°¸ä½“ä¹Ÿå˜å¤§
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(0.5);
                ctx.fillText(fruit.type.emoji, 10, 0);
                ctx.restore();
                ctx.globalAlpha = 1;
                this.x += this.vx; this.y += this.vy; this.vy += this.gravity; this.life -= 0.03;
            },
            update: function() {} // Dummy
        });
    }

    function createExplosion(x, y, color) {
        // ç‚¸å¼¹çˆ†ç‚¸ç‰¹æ•ˆ
        for (let i = 0; i < 50; i++) {
            const p = new Particle(x, y, '#ff0000');
            p.vx *= 3;
            p.vy *= 3;
            particles.push(p);
        }
        
        // å±å¹•é—ªç™½
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function loseLife() {
        lives--;
        updateUI();
        if (lives <= 0) {
            triggerGameOver();
        }
    }

    function updateUI() {
        scoreEl.innerText = `åˆ†æ•°: ${score}`;
        let hearts = '';
        for(let i=0; i<lives; i++) hearts += 'â¤ï¸';
        livesEl.innerText = hearts;
    }

    function triggerGameOver() {
        gameState = 'GAMEOVER';
        finalScoreEl.innerText = score;
        
        if (score > bestScore) {
            bestScore = score;
            localStorage.setItem('fruitNinjaBestScore', bestScore);
            bestScoreEl.innerText = `æœ€é«˜: ${bestScore}`;
        }
        
        gameOverScreen.classList.remove('hidden');
    }

    // --- ä¸»å¾ªç¯ ---
    function gameLoop() {
        if (gameState !== 'PLAYING' && particles.length === 0) return;

        // æ¸…ç©ºç”»å¸ƒ
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // ç•™ä¸‹ä¸€ç‚¹æ®‹å½±è½¨è¿¹è®©åŠ¨ä½œæ›´æµç•…
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        gameTime++;
        difficultyMultiplier = 1 + (gameTime / 1000);

        // æ›´æ–°å’Œç»˜åˆ¶æ°´æœ
        fruits.forEach(fruit => {
            fruit.update();
            fruit.draw();
        });

        // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            if (p.update) p.update(); // æŸäº›ç‰¹æ®Šå¯¹è±¡æœ‰è‡ªå®šä¹‰update
            else {
                // Duck typing fallback for simple particles
            }
            
            if (p.draw) p.draw();
            else if (p instanceof Particle) p.draw();

            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }

        // åˆ€å…‰è½¨è¿¹
        updateTrail();
        drawTrail();

        requestAnimationFrame(gameLoop);
    }
    
    // åˆå§‹ç”»é¢æ¸²æŸ“
    resize();
    ctx.fillStyle = "#fff";
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("å‡†å¤‡å¥½äº†å—ï¼Ÿ", canvas.width/2, canvas.height/2);

</script>
</body>
</html>